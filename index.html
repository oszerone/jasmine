<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Jasmine : jasmine2cn" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Jasmine</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/oszerone/jasmine">View on GitHub</a>

          <h1 id="project_title">Jasmine</h1>
          <h2 id="project_tagline">jasmine2cn</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/oszerone/jasmine/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/oszerone/jasmine/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <p>&lt;!DOCTYPE html&gt;</p>



<p>
</p>
  introduction-1.3.1.js
  &lt;!--- boot.js is required only for Jasmine 2.x ---&gt;
  <div>
  <div></div>
  <div>
    <a href="http://github.com/pivotal/jasmine">
      <img src="./Jasmine_introduction-1.3.1.js.cn_files/jasmine_logo.png"></a>
    
    <div>
      版权
    </div>
    <a href="http://pivotallabs.com/" target="_blank">
      <img src="./Jasmine_introduction-1.3.1.js.cn_files/pivotal_logo.gif"></a>
  </div>
  <table cellspacing="0" cellpadding="0">
<tr>
<th>
        <h1>入门简介-1.3.1.js</h1>
      </th>
      <th></th>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-1">¶</a>
        </div>
        <p>Jasmine是测试JavaScript代码的一个行为驱动开发框架。它不依赖任何JavaScript框架。不需要DOM。而且它干净、简洁的语法可以让你很容易编写测试。</p>
        <p>本指南针对Jasmine版本1.3.1 修订本 1354556913</p>
      </td>
      <td>
        <div>
          <pre></pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-Suites:_&lt;code&gt;describe&lt;/code&gt;_Your_Tests">¶</a>
        </div>
        <h2>规则集合: <code>describe</code> 你的测试</h2>

<p>一个测试规则集合通过调用有两个参数（一个string，一个function）的全局Jasmine函数<code>describe</code>开始。string参数是规则集合的名称或者标题 - 通常说明下面的测试。function参数是实现了规则集合的代码块。</p>

<h2>规则</h2>

<p>规则通过调用全局Jasmine函数<code>it</code>来定义，像<code>describe</code>一样it也有一个string和function参数。string参数是规则的标题，function参数是规则或者测试。规则包括一个或多个测试代码执行后的状态预望（可以说是断言吧）</p>

<p>预期在Jasmine中是true或者false的断言。规则中的所有预期都为true则是一个通过的规则。规则中有一个或者多个false的预期则为失败的规则。</p>
      </td>
      <td>
        <div>
          <pre>describe("A suite", function() {
  it("contains spec with an expectation", function() {
    expect(true).toBe(true);
  });
});</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-It%E2%80%99s_Just_Functions">¶</a>
        </div>
        <h3>它仅仅是一个函数</h3>

<p>由于<code>describe</code>和<code>it</code>块是函数，所以它们可以包含实现测试所需要的任何可执行代码。JavaScript作用域规则也适用，所以在<code>describe</code>中声明的变量可以在规则集合中的任何<code>it</code>块中使用。</p>
      </td>
      <td>
        <div>
          <pre>describe("A suite is just a function", function() {
  var a;

  it("and so is a spec", function() {
    a = true;

    expect(a).toBe(true);
  });
});</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-Expectations">¶</a>
        </div>
        <h2>预期</h2>

<p>预期通过给<code>expect</code>函数传递真实值参数来创建。它链式调用一个需要期望值参数的匹配程序。</p>
      </td>
      <td>
        <div>
          <pre>describe("The 'toBe' matcher compares with ===", function() {</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-Matchers">¶</a>
        </div>
        <h3>匹配程序</h3>

<p>每一个匹配程序实现真实值和预期值的布尔比较功能。它负责报告预期的真或假结果给Jasmine，然后Jasmine将设置规则为通过或失败。</p>
      </td>
      <td>
        <div>
          <pre>  it("and has a positive case ", function() {
    expect(true).toBe(true);
  });</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-6">¶</a>
        </div>
        <p>任何匹配程序都可以在<code>expect</code>调用匹配程序前链式调用一个<code>not</code>取得一个相反的断言。</p>
      </td>
      <td>
        <div>
          <pre>  it("and can have a negative case", function() {
    expect(false).not.toBe(true);
  });
});</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-Included_Matchers">¶</a>
        </div>
        <h3>已包含的匹配程序</h3>

<p>Jasmine有一组丰富的匹配程序。右边的预期和规则使用了已提供的所有匹配程序。</p>

<p>当项目中需要调用没有提供的特殊断言时，我们也可以编写自定义匹配程序<a href="https://github.com/pivotal/jasmine/wiki/Matchers">custom matchers</a></p>
      </td>
      <td>
        <div>
          <pre>describe("Included matchers:", function() {

  it("The 'toBe' matcher compares with ===", function() {
    var a = 12;
    var b = a;

    expect(a).toBe(b);
    expect(a).not.toBe(null);
  });

  describe("The 'toEqual' matcher", function() {

    it("works for simple literals and variables", function() {
      var a = 12;
      expect(a).toEqual(12);
    });

    it("should work for objects", function() {
      var foo = {
        a: 12,
        b: 34
      };
      var bar = {
        a: 12,
        b: 34
      };
      expect(foo).toEqual(bar);
    });
  });

  it("The 'toMatch' matcher is for regular expressions", function() {
    var message = 'foo bar baz';

    expect(message).toMatch(/bar/);
    expect(message).toMatch('bar');
    expect(message).not.toMatch(/quux/);
  });

  it("The 'toBeDefined' matcher compares against `undefined`", function() {
    var a = {
      foo: 'foo'
    };

    expect(a.foo).toBeDefined();
    expect(a.bar).not.toBeDefined();
  });

  it("The `toBeUndefined` matcher compares against `undefined`", function() {
    var a = {
      foo: 'foo'
    };

    expect(a.foo).not.toBeUndefined();
    expect(a.bar).toBeUndefined();
  });

  it("The 'toBeNull' matcher compares against null", function() {
    var a = null;
    var foo = 'foo';

    expect(null).toBeNull();
    expect(a).toBeNull();
    expect(foo).not.toBeNull();
  });

  it("The 'toBeTruthy' matcher is for boolean casting testing", function() {
    var a, foo = 'foo';

    expect(foo).toBeTruthy();
    expect(a).not.toBeTruthy();
  });

  it("The 'toBeFalsy' matcher is for boolean casting testing", function() {
    var a, foo = 'foo';

    expect(a).toBeFalsy();
    expect(foo).not.toBeFalsy();
  });

  it("The 'toContain' matcher is for finding an item in an Array", function() {
    var a = ['foo', 'bar', 'baz'];

    expect(a).toContain('bar');
    expect(a).not.toContain('quux');
  });

  it("The 'toBeLessThan' matcher is for mathematical comparisons", function() {
    var pi = 3.1415926, e = 2.78;

    expect(e).toBeLessThan(pi);
    expect(pi).not.toBeLessThan(e);
  });

  it("The 'toBeGreaterThan' is for mathematical comparisons", function() {
    var pi = 3.1415926, e = 2.78;

    expect(pi).toBeGreaterThan(e);
    expect(e).not.toBeGreaterThan(pi);
  });

  it("The 'toBeCloseTo' matcher is for precision math comparison", function() {
    var pi = 3.1415926, e = 2.78;

    expect(pi).not.toBeCloseTo(e, 2);
    expect(pi).toBeCloseTo(e, 0);
  });

  it("The 'toThrow' matcher is for testing if a function throws an exception", function() {
    var foo = function() {
      return 1 + 2;
    };
    var bar = function() {
      return a + 1;
    };

    expect(foo).not.toThrow();
    expect(bar).toThrow();
  });
});</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-Grouping_Related_Specs_with_&lt;code&gt;describe&lt;/code&gt;">¶</a>
        </div>
        <h2>使用<code>describe</code>分组相关联的规则</h2>

<p>函数<code>describe</code>可以分组相关联的规则。string参数是这个规则集合的名称，它将连接规则名称作为一个规则的全称，这样方便在大量规则集合中查找规则。
如果你的名称起的比较好，你的规则读起来像传统<a href="http://en.wikipedia.org/wiki/Behavior-driven_development">BDD</a>风格的一整句话。</p>
      </td>
      <td>
        <div>
          <pre>describe("A spec", function() {
  it("is just a function, so it can contain any code", function() {
    var foo = 0;
    foo += 1;

    expect(foo).toEqual(1);
  });

  it("can have more than one expectation", function() {
    var foo = 0;
    foo += 1;

    expect(foo).toEqual(1);
    expect(true).toEqual(true);
  });
});</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-Setup_and_Teardown">¶</a>
        </div>
        <h3>Setup and Teardown</h3>

<p>To help a test suite DRY up any duplicated setup and teardown code, Jasmine provides the global <code>beforeEach</code> and <code>afterEach</code> functions. As the name implies the <code>beforeEach</code> function is called once before each spec in the <code>describe</code> is run and the <code>afterEach</code> function is called once after each spec.</p>

<p>Here is the same set of specs written a little differently. The variable under test is defined at the top-level scope — the <code>describe</code> block —  and initialization code is moved into a <code>beforeEach</code> function. The <code>afterEach</code> function resets the variable before continuing.</p>
      </td>
      <td>
        <div>
          <pre>describe("A spec (with setup and tear-down)", function() {
  var foo;

  beforeEach(function() {
    foo = 0;
    foo += 1;
  });

  afterEach(function() {
    foo = 0;
  });

  it("is just a function, so it can contain any code", function() {
    expect(foo).toEqual(1);
  });

  it("can have more than one expectation", function() {
    expect(foo).toEqual(1);
    expect(true).toEqual(true);
  });
});</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-Nesting_&lt;code&gt;describe&lt;/code&gt;_Blocks">¶</a>
        </div>
        <h3>Nesting <code>describe</code> Blocks</h3>

<p>Calls to <code>describe</code> can be nested, with specs defined at any level. This allows a suite to be composed as a tree of functions. Before a spec is executed, Jasmine walks down the tree executing each <code>beforeEach</code> function in order. After the spec is executed, Jasmine walks through the <code>afterEach</code> functions similarly.</p>
      </td>
      <td>
        <div>
          <pre>describe("A spec", function() {
  var foo;

  beforeEach(function() {
    foo = 0;
    foo += 1;
  });

  afterEach(function() {
    foo = 0;
  });

  it("is just a function, so it can contain any code", function() {
    expect(foo).toEqual(1);
  });

  it("can have more than one expectation", function() {
    expect(foo).toEqual(1);
    expect(true).toEqual(true);
  });

  describe("nested inside a second describe", function() {
    var bar;

    beforeEach(function() {
      bar = 1;
    });

    it("can reference both scopes as needed ", function() {
      expect(foo).toEqual(bar);
    });
  });
});</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-Disabling_Specs_and_Suites">¶</a>
        </div>
        <h2>Disabling Specs and Suites</h2>

<p>Suites and specs can be disabled with the <code>xdescribe</code> and <code>xit</code> functions, respectively. These suites and specs are skipped when run and thus their results will not appear in the results.</p>
      </td>
      <td>
        <div>
          <pre>xdescribe("A spec", function() {
  var foo;

  beforeEach(function() {
    foo = 0;
    foo += 1;
  });

  xit("is just a function, so it can contain any code", function() {
    expect(foo).toEqual(1);
  });
});</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-Spies">¶</a>
        </div>
        <h2>Spies</h2>

<p>Jasmine’s test doubles are called spies. A spy can stub any function and tracks calls to it and all arguments. There are special matchers for interacting with spies.</p>

<p>The <code>toHaveBeenCalled</code> matcher will return true if the spy was called. The <code>toHaveBeenCalledWith</code> matcher will return true if the argument list matches any of the recorded calls to the spy.</p>
      </td>
      <td>
        <div>
          <pre>describe("A spy", function() {
  var foo, bar = null;

  beforeEach(function() {
    foo = {
      setBar: function(value) {
        bar = value;
      }
    };

    spyOn(foo, 'setBar');

    foo.setBar(123);
    foo.setBar(456, 'another param');
  });

  it("tracks that the spy was called", function() {
    expect(foo.setBar).toHaveBeenCalled();
  });

  it("tracks its number of calls", function() {
    expect(foo.setBar.calls.length).toEqual(2);
  });

  it("tracks all the arguments of its calls", function() {
    expect(foo.setBar).toHaveBeenCalledWith(123);
    expect(foo.setBar).toHaveBeenCalledWith(456, 'another param');
  });

  it("allows access to the most recent call", function() {
    expect(foo.setBar.mostRecentCall.args[0]).toEqual(456);
  });

  it("allows access to other calls", function() {
    expect(foo.setBar.calls[0].args[0]).toEqual(123);
  });

  it("stops all execution on a function", function() {
    expect(bar).toBeNull();
  });
});</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-Spies:_&lt;code&gt;andCallThrough&lt;/code&gt;">¶</a>
        </div>
        <h3>Spies: <code>andCallThrough</code>
</h3>

<p>By chaining the spy with <code>andCallThrough</code>, the spy will still track all calls to it but in addition it will delegate to the actual implementation.</p>
      </td>
      <td>
        <div>
          <pre>describe("A spy, when configured to call through", function() {
  var foo, bar, fetchedBar;

  beforeEach(function() {
    foo = {
      setBar: function(value) {
        bar = value;
      },
      getBar: function() {
        return bar;
      }
    };

    spyOn(foo, 'getBar').andCallThrough();

    foo.setBar(123);
    fetchedBar = foo.getBar();
  });

  it("tracks that the spy was called", function() {
    expect(foo.getBar).toHaveBeenCalled();
  });

  it("should not effect other functions", function() {
    expect(bar).toEqual(123);
  });

  it("when called returns the requested value", function() {
    expect(fetchedBar).toEqual(123);
  });
});</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-Spies:_&lt;code&gt;andReturn&lt;/code&gt;">¶</a>
        </div>
        <h3>Spies: <code>andReturn</code>
</h3>

<p>By chaining the spy with <code>andReturn</code>, all calls to the function will return a specific value.</p>
      </td>
      <td>
        <div>
          <pre>describe("A spy, when faking a return value", function() {
  var foo, bar, fetchedBar;

  beforeEach(function() {
    foo = {
      setBar: function(value) {
        bar = value;
      },
      getBar: function() {
        return bar;
      }
    };

    spyOn(foo, 'getBar').andReturn(745);

    foo.setBar(123);
    fetchedBar = foo.getBar();
  });

  it("tracks that the spy was called", function() {
    expect(foo.getBar).toHaveBeenCalled();
  });

  it("should not effect other functions", function() {
    expect(bar).toEqual(123);
  });

  it("when called returns the requested value", function() {
    expect(fetchedBar).toEqual(745);
  });
});</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-Spies:_&lt;code&gt;andCallFake&lt;/code&gt;">¶</a>
        </div>
        <h3>Spies: <code>andCallFake</code>
</h3>

<p>By chaining the spy with <code>andCallFake</code>, all calls to the spy will delegate to the supplied function.</p>
      </td>
      <td>
        <div>
          <pre>describe("A spy, when faking a return value", function() {
  var foo, bar, fetchedBar;

  beforeEach(function() {
    foo = {
      setBar: function(value) {
        bar = value;
      },
      getBar: function() {
        return bar;
      }
    };

    spyOn(foo, 'getBar').andCallFake(function() {
      return 1001;
    });

    foo.setBar(123);
    fetchedBar = foo.getBar();
  });

  it("tracks that the spy was called", function() {
    expect(foo.getBar).toHaveBeenCalled();
  });

  it("should not effect other functions", function() {
    expect(bar).toEqual(123);
  });

  it("when called returns the requested value", function() {
    expect(fetchedBar).toEqual(1001);
  });
});</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-Spies:_&lt;code&gt;createSpy&lt;/code&gt;">¶</a>
        </div>
        <h3>Spies: <code>createSpy</code>
</h3>

<p>When there is not a function to spy on, <code>jasmine.createSpy</code> can create a “bare” spy. This spy acts as any other spy – tracking calls, arguments, etc. But there is no implementation behind it. Spies are JavaScript objects and can be used as such.</p>
      </td>
      <td>
        <div>
          <pre>describe("A spy, when created manually", function() {
  var whatAmI;

  beforeEach(function() {
    whatAmI = jasmine.createSpy('whatAmI');

    whatAmI("I", "am", "a", "spy");
  });

  it("is named, which helps in error reporting", function() {
    expect(whatAmI.identity).toEqual('whatAmI')
  });

  it("tracks that the spy was called", function() {
    expect(whatAmI).toHaveBeenCalled();
  });

  it("tracks its number of calls", function() {
    expect(whatAmI.calls.length).toEqual(1);
  });

  it("tracks all the arguments of its calls", function() {
    expect(whatAmI).toHaveBeenCalledWith("I", "am", "a", "spy");
  });

  it("allows access to the most recent call", function() {
    expect(whatAmI.mostRecentCall.args[0]).toEqual("I");
  });
});</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-Spies:_&lt;code&gt;createSpyObj&lt;/code&gt;">¶</a>
        </div>
        <h3>Spies: <code>createSpyObj</code>
</h3>

<p>In order to create a mock with multiple spies, use <code>jasmine.createSpyObj</code> and pass an array of strings. It returns an object that has a property for each string that is a spy.</p>
      </td>
      <td>
        <div>
          <pre>describe("Multiple spies, when created manually", function() {
  var tape;

  beforeEach(function() {
    tape = jasmine.createSpyObj('tape', ['play', 'pause', 'stop', 'rewind']);

    tape.play();
    tape.pause();
    tape.rewind(0);
  });

  it("creates spies for each requested function", function() {
    expect(tape.play).toBeDefined();
    expect(tape.pause).toBeDefined();
    expect(tape.stop).toBeDefined();
    expect(tape.rewind).toBeDefined();
  });

  it("tracks that the spies were called", function() {
    expect(tape.play).toHaveBeenCalled();
    expect(tape.pause).toHaveBeenCalled();
    expect(tape.rewind).toHaveBeenCalled();
    expect(tape.stop).not.toHaveBeenCalled();
  });

  it("tracks all the arguments of its calls", function() {
    expect(tape.rewind).toHaveBeenCalledWith(0);
  });
});</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-Matching_Anything_with_&lt;code&gt;jasmine.any&lt;/code&gt;">¶</a>
        </div>
        <h2>Matching Anything with <code>jasmine.any</code>
</h2>

<p><code>jasmine.any</code> takes a constructor or “class” name as an expected value. It returns <code>true</code> if the constructor matches the constructor of the actual value.</p>
      </td>
      <td>
        <div>
          <pre>describe("jasmine.any", function() {
  it("matches any value", function() {
    expect({}).toEqual(jasmine.any(Object));
    expect(12).toEqual(jasmine.any(Number));
  });

  describe("when used with a spy", function() {
    it("is useful for comparing arguments", function() {
      var foo = jasmine.createSpy('foo');
      foo(12, function() {
        return true
      });

      expect(foo).toHaveBeenCalledWith(jasmine.any(Number), jasmine.any(Function));
    });
  });
});</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-Mocking_the_JavaScript_Clock">¶</a>
        </div>
        <h2>Mocking the JavaScript Clock</h2>

<p>The Jasmine Mock Clock is available for a test suites that need the ability to use <code>setTimeout</code> or <code>setInterval</code> callbacks. It makes the timer callbacks synchronous, thus making them easier to test.</p>
      </td>
      <td>
        <div>
          <pre>describe("Manually ticking the Jasmine Mock Clock", function() {
  var timerCallback;</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-20">¶</a>
        </div>
        <p>It is installed with a call to <code>jasmine.Clock.useMock</code> in a spec or suite that needs to call the timer functions.</p>
      </td>
      <td>
        <div>
          <pre>  beforeEach(function() {
    timerCallback = jasmine.createSpy('timerCallback');
    jasmine.Clock.useMock();
  });</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-21">¶</a>
        </div>
        <p>Calls to any registered callback are triggered when the clock is ticked forward via the <code>jasmine.Clock.tick</code> function, which takes a number of milliseconds.</p>
      </td>
      <td>
        <div>
          <pre>  it("causes a timeout to be called synchronously", function() {
    setTimeout(function() {
      timerCallback();
    }, 100);

    expect(timerCallback).not.toHaveBeenCalled();

    jasmine.Clock.tick(101);

    expect(timerCallback).toHaveBeenCalled();
  });

  it("causes an interval to be called synchronously", function() {
    setInterval(function() {
      timerCallback();
    }, 100);

    expect(timerCallback).not.toHaveBeenCalled();

    jasmine.Clock.tick(101);
    expect(timerCallback.callCount).toEqual(1);

    jasmine.Clock.tick(50);
    expect(timerCallback.callCount).toEqual(1);

    jasmine.Clock.tick(50);
    expect(timerCallback.callCount).toEqual(2);
  });
});</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-Asynchronous_Support">¶</a>
        </div>
        <h2>Asynchronous Support</h2>

<p>Jasmine also has support for running specs that require testing asynchronous operations.</p>
      </td>
      <td>
        <div>
          <pre>describe("Asynchronous specs", function() {
  var value, flag;

  it("should support async execution of test preparation and exepectations", function() {</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-23">¶</a>
        </div>
        <p>Specs are written by defining a set of blocks with calls to <code>runs</code>, which usually finish with an asynchronous call.</p>
      </td>
      <td>
        <div>
          <pre>    runs(function() {
      flag = false;
      value = 0;

      setTimeout(function() {
        flag = true;
      }, 500);
    });</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-24">¶</a>
        </div>
        <p>The <code>waitsFor</code> block takes a latch function, a failure message, and a timeout.</p>

<p>The latch function polls until it returns true or the timeout expires, whichever comes first. If the timeout expires, the spec fails with the error message.</p>
      </td>
      <td>
        <div>
          <pre>    waitsFor(function() {
      value++;
      return flag;
    }, "The Value should be incremented", 750);</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-25">¶</a>
        </div>
        <p>Once the asynchronous conditions have been met, another <code>runs</code> block defines final test behavior. This is usually expectations based on state after the asynch call returns.</p>
      </td>
      <td>
        <div>
          <pre>    runs(function() {
      expect(value).toBeGreaterThan(0);
    });
  });
});</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-The_Runner_and_Reporter">¶</a>
        </div>
        <h2>The Runner and Reporter</h2>

<p>Jasmine is built in JavaScript and must be included into a JS environment, such as a web page, in order to run. Like this web page.</p>

<p>This file is written in JavaScript and is compiled into HTML via <a href="http://rtomayko.github.com/rocco/">Rocco</a>. The JavaScript file is then included, via a <code>&lt;script&gt;</code> tag, so that all of the above specs are evaluated and recorded with Jasmine. Thus Jasmine can run all of these specs. This page is then considered a ‘runner.’</p>

<p>Scroll down the page to see the results of the above specs. All of the specs should pass.</p>

<p>Meanwhile, here is how a runner works to execute a Jasmine suite.</p>
      </td>
      <td>
        <div>
          <pre>(function() {
  var jasmineEnv = jasmine.getEnv();
  jasmineEnv.updateInterval = 250;</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-27">¶</a>
        </div>
        <p>Create the <code>HTMLReporter</code>, which Jasmine calls to provide results of each spec and each suite. The Reporter is responsible for presenting results to the user.</p>
      </td>
      <td>
        <div>
          <pre>  var htmlReporter = new jasmine.HtmlReporter();
  jasmineEnv.addReporter(htmlReporter);</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-28">¶</a>
        </div>
        <p>Delegate filtering of specs to the reporter. Allows for clicking on single suites or specs in the results to only run a subset of the suite.</p>
      </td>
      <td>
        <div>
          <pre>  jasmineEnv.specFilter = function(spec) {
    return htmlReporter.specFilter(spec);
  };</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-Test_Results">¶</a>
        </div>
        <p>Run all of the tests when the page finishes loading – and make sure to run any previous <code>onload</code> handler</p>

<h3>Test Results</h3>

<p>Scroll down to see the results of all of these specs.</p>
      </td>
      <td>
        <div>
          <pre>  var currentWindowOnload = window.onload;
  window.onload = function() {
    if (currentWindowOnload) {
      currentWindowOnload();
    }

    document.querySelector('.version').innerHTML = jasmineEnv.versionString();
    execJasmine();
  };

  function execJasmine() {
    jasmineEnv.execute();
  }
})();</pre>
        </div>
      </td>
    </tr>
<tr>
<td>
        <div>
          <a href="http://pivotal.github.com/jasmine/#section-Downloads">¶</a>
        </div>
        <h2>Downloads</h2>

<ul>
<li>The <a href="http://github.com/pivotal/jasmine/downloads">Standalone Release</a> is for simple, browser page, or console projects</li>
<li>The <a href="http://github.com/pivotal/jasmine-gem">Jasmine Ruby Gem</a> is for Rails, Ruby, or Ruby-friendly development</li>
<li>
<a href="http://github.com/pivotal/jasmine/wiki">Other Environments</a> are supported as well</li>
</ul>
<h2>Support</h2>

<ul>
<li>
<a href="http://groups.google.com/group/jasmine-js">Mailing list</a> at Google Groups – a great first stop to ask questions, propose features, or discuss pull requests</li>
<li>
<a href="http://github.com/pivotal/jasmine/issues">Report Issues</a> at Github</li>
<li>The <a href="http://www.pivotaltracker.com/projects/10606">Backlog</a> lives at <a href="http://www.pivotaltracker.com/">Pivotal Tracker</a>
</li>
<li>Follow <a href="http://twitter.com/jasminebdd">@JasmineBDD</a> on Twitter</li>
</ul>
<h2>Thanks</h2>

<p><em>Running documentation inspired by <a href="http://twitter.com/mjackson">@mjackson</a> and the 2012 <a href="http://fluentconf.com/">Fluent</a> Summit.</em></p>

      </td>
      <td>
        <div>
          <pre></pre>
        </div>
      </td>
    </tr>
</table>
</div>

<p></p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Jasmine maintained by <a href="https://github.com/oszerone">oszerone</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
